[
  {
    "bID": 50,
    "bsubmitter": "fffff",
    "btitle": "Mvc model验证总结",
    "bcategory": "技术博文",
    "bcontent": "<h2><em>Model&nbsp;验证总结</em></h2><p><a href=https://www.cnblogs.com/starksoft/p/5616889.html rel=noopener noreferrer target=_blank>https://www.cnblogs.com/starksoft/p/5616889.html</a></p><p><br></p><p><br></p><p><br></p><p>Model&nbsp;验证总结&nbsp;1</p><p>一．Model&nbsp;验证标记&nbsp;1</p><p>1、启用客户端验证： 1</p><p>2、在&nbsp;Model&nbsp;中加入验证标记&nbsp;2</p><p>3&nbsp;、&nbsp;Model&nbsp;类中可以添加的验证标记：&nbsp;3</p><p>3.1、必填字段 3</p><p>3.2&nbsp;、&nbsp;字段长度 3</p><p>3.3&nbsp;、&nbsp;正则验证 3</p><p>3.4、范围 4</p><p>3.5、服务端参与的",
    "btraffic": 461,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": "Model验证总结https://www.cnblogs.com/starksoft/p/5616889.htmlModel验证总结1一．Model验证标记11、启用客户端验证： 12、在Model中加入验证标记23、Model类中可以添加的验证标记：33.1、必填字段 33.2、字段长度 33.3、正则验证 33.4、范围 43.5、服务端参与的验证 43.6、比较 43.7、自定义错误消息 5",
    "IsDeleted": false
  },
  {
    "bID": 48,
    "bsubmitter": "学习",
    "btitle": "《WebAPI Get请求参数传入输入带有[]不识别问题》",
    "bcategory": "技术博文",
    "bcontent": "<p>在Framwork 体系下 WebAPI项目 会有很多默认特性，例如：Get查询竟然支持三种数组查询方式</p><p>1.https://localhost:44390/api/values?status=1&amp;status=2</p><p>2.https://localhost:44390/api/values?status[]=1&amp;status[]=2</p><p>3.https://localhost:44390/api/values?status[0]=1&amp;status[1]=2</p><p><br></p><p>&lt;img src=<span style=background-color: rgb(255, 255, 255);>http://123.206.33.109:7090/images%5C0506120113image.png</span> /&gt;</p><p><br></p><p>直到客户端同鞋找到我，才发现第二种在.net core webapi 默认竟然不支持</p><p>于是google了好久加上询问大牛，才找到",
    "btraffic": 188,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": "在Framwork 体系下 WebAPI项目 会有很多默认特性，例如：Get查询竟然支持三种数组查询方式1.https://localhost:44390/api/values?status=1status=22.https://localhost:44390/api/values?status[]=1status[]=23.https://localhost:44390/api/values?s",
    "IsDeleted": false
  },
  {
    "bID": 46,
    "bsubmitter": "学习",
    "btitle": ".Net Core 迁移之坑一 《WebAPI Get请求参数传入输入带有[]不识别问题》",
    "bcategory": "技术博文",
    "bcontent": "<p>在Framwork 体系下 WebAPI项目 会有很多默认特性，例如：Get查询竟然支持三种数组查询方式</p><p>1.https://localhost:44390/api/values?status=1&amp;status=2</p><p>2.https://localhost:44390/api/values?status[]=1&amp;status[]=2</p><p>3.https://localhost:44390/api/values?status[0]=1&amp;status[1]=2</p><p><img src=https://images2018.cnblogs.com/blog/384514/201807/384514-20180715165114365-1220720659.png></p><p>直到客户端同鞋找到我，才发现第二种在.net core webapi 默认竟然不支持</p><p>于是google了好久加上询问大牛，才找到一个解决方案，就是通过&nbsp;Conventions 解决</p><p><img src=https:/",
    "btraffic": 143,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": "在Framwork 体系下 WebAPI项目 会有很多默认特性，例如：Get查询竟然支持三种数组查询方式1.https://localhost:44390/api/values?status=1status=22.https://localhost:44390/api/values?status[]=1status[]=23.https://localhost:44390/api/values?s",
    "IsDeleted": false
  },
  {
    "bID": 42,
    "bsubmitter": "对对对",
    "btitle": "代码：JS继承 + C# 单例模式",
    "bcategory": "技术博文",
    "bcontent": "<h2>&nbsp;单例模型</h2><p><br></p><pre class=ql-syntax spellcheck=false> &nbsp; public class Singleton\n&nbsp; &nbsp; {\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 定义一个静态变量来保存类的实例\n&nbsp; &nbsp; &nbsp; &nbsp; private static Singleton uniqueInstance;\n&nbsp; &nbsp; &nbsp; &nbsp; // 定义一个标识确保线程同步\n&nbsp; &nbsp; &nbsp; &nbsp; private static readonly object locker = new object();\n&nbsp; &nbsp; &nbsp; &nbsp; // 定义私有构造函数，使外界不能创建该类实例\n&nbsp; &nbsp; &nbsp; &nbsp; private Singleton()\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &",
    "btraffic": 247,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": "单例模型  public class Singleton\n  {\n\n    // 定义一个静态变量来保存类的实例\n    private static Singleton uniqueInstance;\n    // 定义一个标识确保线程同步\n    private static readonly object locker = new object();\n    // 定义私有构造函数，使外界不",
    "IsDeleted": false
  },
  {
    "bID": 41,
    "bsubmitter": "IIS",
    "btitle": "IIS的工作原理？",
    "bcategory": "技术博文",
    "bcontent": "<p>1、当客户端发送HTTP Request时，服务端的HTTP.sys（可以理解为IIS的一个监听组件） 拦截到这个请求；</p><p>2、HTTP.sys 联系 WAS 向配置存储中心请求配置信息。</p><p>3、然后将请求传入IIS的应用程序池。</p><p>4、检查请求的后缀，启动aspnet_isapi.dll这个dll，这个dll是.net framework里面的，也就是说到这一步，请求进入了.net framework的管辖范围。</p><p>5、这个时候如果是WebForm，开始执行复杂的页面生命周期（HttpRuntime→ProcessRequest→HttpContext→HttpHandler）；如果是MVC，则启动mvc的路由机制，根据路由规则为URL来指定HttpHandler。</p><p>6、httpHandler处理请求后，请求结束，给出Response，客户端处理响应，整个过程结束。</p>",
    "btraffic": 140,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": "1、当客户端发送HTTP Request时，服务端的HTTP.sys（可以理解为IIS的一个监听组件） 拦截到这个请求；2、HTTP.sys 联系 WAS 向配置存储中心请求配置信息。3、然后将请求传入IIS的应用程序池。4、检查请求的后缀，启动aspnet_isapi.dll这个dll，这个dll是.net framework里面的，也就是说到这一步，请求进入了.net framework的管辖",
    "IsDeleted": false
  },
  {
    "bID": 40,
    "bsubmitter": "laozhang",
    "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 39,
    "bsubmitter": "laozhang",
    "btitle": "Enmm？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 226,
    "bcommentNum": 0,
    "bUpdateTime": "2019-04-01T00:00:00",
    "bCreateTime": "2019-02-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 38,
    "bsubmitter": "laozhang",
    "btitle": "Oo...？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 37,
    "bsubmitter": "laozhang",
    "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 36,
    "bsubmitter": "laozhang",
    "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 35,
    "bsubmitter": "laozhang",
    "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 34,
    "bsubmitter": "laozhang",
    "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 33,
    "bsubmitter": "laozhang",
    "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 32,
    "bsubmitter": "laozhang",
    "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 31,
    "bsubmitter": "laozhang",
    "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 25,
    "bsubmitter": "laozhang",
    "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 24,
    "bsubmitter": "laozhang",
    "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 23,
    "bsubmitter": "laozhang",
    "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 22,
    "bsubmitter": "laozhang",
    "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 21,
    "bsubmitter": "laozhang",
    "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 15,
    "bsubmitter": "laozhang",
    "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 14,
    "bsubmitter": "laozhang",
    "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 13,
    "bsubmitter": "laozhang",
    "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 12,
    "bsubmitter": "laozhang",
    "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  },
  {
    "bID": 11,
    "bsubmitter": "laozhang",
    "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
    "bcategory": "技术博文",
    "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
    "btraffic": 227,
    "bcommentNum": 0,
    "bUpdateTime": "2019-01-01T00:00:00",
    "bCreateTime": "2019-01-01T00:00:00",
    "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
    "IsDeleted": false
  }
]